package medium;

public class T300最长递增子序列 {
    public static void main(String[] args) {
        int nums[] = {10, 9, 2, 5, 3, 7, 101, 18};
        System.out.println(lengthOfLIS2(nums));

    }

    /*
    * 动态规划
    首先，我们检查数组的长度是否为零，如果是零，则直接返回 0，因为没有元素可以构成递增子序列。

    创建一个大小为数组长度的 dp 数组，用来记录以每个元素为结尾的最长递增子序列的长度。

    初始化 dp 数组的第一个元素为 1，表示以第一个元素为结尾的最长递增子序列的长度为 1。

    创建一个变量 maxLength，用来记录最长递增子序列的长度，默认值为 1。

    从数组的第二个元素开始遍历。

    对于当前元素 nums[i]，我们将其最长递增子序列长度初始化为 1。

    然后，我们遍历当前元素之前的所有元素 nums[j]（其中 j < i）。

    如果当前元素 nums[i] 大于之前的元素 nums[j]，说明我们可以将当前元素添加到以 nums[j] 结尾的递增子序列中，从而形成一个更长的递增子序列。

    我们通过比较当前元素的最长递增子序列长度 dp[i] 和以 nums[j] 结尾的递增子序列长度加 1 的值 dp[j] + 1，选择较大的值来更新当前元素的最长递增子序列长度。

    在每次迭代中，我们还会比较当前元素的最长递增子序列长度 dp[i] 和之前的最长递增子序列的长度 maxLength，选择较大的值作为最长递增子序列的长度。

    最后，我们返回 maxLength，即为最长递增子序列的长度。

    时间复杂度：O(n^2)，其中 n 为数组的长度。动态规划的状态数为 n，计算状态 dp[i] 时，需要 O(n) 的时间遍历 dp[0…i−1] 的所有状态，所以总时间复杂度为 O(n^2)。
    空间复杂度：O(n)，其中 n 为数组的长度。需要创建一个大小为 n 的 dp 数组。
    *
     */
    public static int lengthOfLIS1(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }

        int[] dp = new int[n]; // dp数组用于记录以每个元素为结尾的最长递增子序列的长度
        dp[0] = 1; // 初始化dp数组，每个元素至少可以作为一个递增子序列
        int maxLength = 1; // 记录最长递增子序列的长度

        for (int i = 1; i < n; i++) {
            dp[i] = 1; // 初始化当前元素的最长递增子序列长度为1
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1); // 如果当前元素大于前面的元素，则更新最长递增子序列长度
                }
            }
            maxLength = Math.max(maxLength, dp[i]); // 更新最长递增子序列的长度
        }

        return maxLength; // 返回最长递增子序列的长度
    }

    /*
        * 贪心 + 二分查找
        * 时间复杂度：O(nlogn)，其中 n 为数组的长度。二分查找的时间复杂度为 O(logn)，对数组中的每个元素都进行二分查找，所以总时间复杂度为 O(nlogn)。
        * 空间复杂度：O(n)，其中 n 为数组的长度。需要创建一个大小为 n 的 dp 数组。
        *
        * 思路
        * 初始化一个长度为1的辅助数组d，用于存储最长递增子序列。
        * 遍历给定的数组nums，从第二个元素开始。
        * 如果当前元素大于辅助数组d中的最后一个元素，说明当前元素可以加入最长递增子序列，将其添加到辅助数组d的末尾，并更新最长递增子序列的长度len。
        * 否则，使用二分查找在辅助数组d中找到合适的插入位置pos，保持递增的特性。将当前元素插入到辅助数组d中的pos+1位置，并更新最长递增子序列的长度len。
        * 完成数组的遍历后，返回最长递增子序列的长度len。

     */
    public static int lengthOfLIS2(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) { // 处理特殊情况，当数组为空时，最长递增子序列长度为 0
            return 0;
        }
        int[] d = new int[n + 1]; // 创建一个数组 d，用于存储最长递增子序列
        d[len] = nums[0]; // 初始化 d[1] 为数组的第一个元素
        for (int i = 1; i < n; ++i) { // 遍历数组中的每个元素
            if (nums[i] > d[len]) { // 若当前元素大于 d[len]，则将当前元素加入到最长递增子序列中
                d[++len] = nums[i];
            } else { // 否则，需要在 d 数组中找到合适的位置插入当前元素，保持递增的特性
                int l = 1, r = len, pos = 0; // 初始化左指针 l、右指针 r 和插入位置 pos
                while (l <= r) { // 使用二分查找找到插入位置
                    int mid = (l + r) >> 1; // 取中间位置
                    if (d[mid] < nums[i]) { // 若中间元素小于当前元素，则更新插入位置为 mid
                        pos = mid;
                        l = mid + 1;
                    } else { // 若中间元素大于等于当前元素，则更新右指针 r
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i]; // 在插入位置后的下一个位置插入当前元素
            }
        }
        return len; // 返回最长递增子序列的长度
    }

}
