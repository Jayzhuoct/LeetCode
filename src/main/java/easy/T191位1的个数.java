package easy;

public class T191位1的个数 {
    public static void main(String[] args) {
        int n = 00000000000000000000000000001011;
        int i = hammingWeight(n);
        System.out.println(i);
    }

    /*
    public static int bitCount(int i) {
        i = i - ((i >>> 1) & 0x55555555);
        i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
        i = (i + (i >>> 4)) & 0x0f0f0f0f;
        i = i + (i >>> 8);
        i = i + (i >>> 16);
        return i & 0x3f;
    }
    这个方法是一个高效计算一个整数二进制表示中1的个数的算法，也叫做"位计数"或"popcount"算法。
    这个方法使用了一些位运算技巧，可以在不使用循环的情况下计算一个整数二进制表示中1的个数。
    这个方法的实现基于一个事实：一个32位整数可以被分成16组，每组中包含2位。
    因此，可以使用位运算将一个32位整数中所有的2位组合相加，得到这个整数中1的个数。
    具体来说，这个方法将一个32位整数分成如下的4个步骤：
    1. 将每个2位中的1的个数相加，得到每个4位中1的个数。
    这可以通过使用掩码0x55555555（二进制表示为01010101010101010101010101010101）和右移运算实现。
    掩码0x55555555可以用于提取每个2位中的第1位。

    2. 将每个4位中的1的个数相加，得到每个8位中1的个数。
    这可以通过使用掩码0x33333333（二进制表示为00110011001100110011001100110011）和右移运算实现。
    掩码0x33333333可以用于提取每个4位中的第1和第2位。

    3. 将每个8位中的1的个数相加，得到每个16位中1的个数。
    这可以通过使用掩码0x0f0f0f0f（二进制表示为00001111000011110000111100001111）和加法运算实现。
    掩码0x0f0f0f0f可以用于提取每个8位中的第1、第2、第3和第4位。

    4. 将每个16位中的1的个数相加，得到整数中1的总个数。这可以通过右移和加法运算实现。

    最后，返回计算出来的1的总个数，并使用掩码0x3f（二进制表示为00111111）进行截断，保留结果的低6位，因为一个32位整数中最多只有32个1，可以用6位二进制数来表示。

    这个方法的时间复杂度是O(1)，因为它不使用循环，而是使用位运算技巧进行计算，所以它的性能比较高。但是，这个方法的缺点是它的代码可读性比较差，需要一定的时间才能理解这个方法是如何工作的。
     */
    public static int hammingWeight(int n) {
        return Integer.bitCount(n);
    }

    /*
    按位与运算的规则是：如果两个数的对应位都是1，则结果的对应位为1，否则为0。
    这个方法使用了一个循环，每次将整数n和n-1按位与，并将结果赋值给n，然后将计数器count加1。
    这个操作的目的是将整数n中最右边的1变成0，因为n-1会将最右边的1变成0，
    而最右边的1之后的所有位都会变成1，与原来的n按位与之后，最右边的1及其右边的所有位都会变成0，而其他位不变。
    这样，每次循环可以将一个1变成0，并将计数器加1，直到n变成0为止。
    时间复杂度是O(k)，其中k是整数n的二进制表示中1的个数。
    由于整数n的二进制表示中1的个数最多为32（对于32位机器），
    时间复杂度是O(1)。
     */
    public static int hammingWeight2(int n) {
        int count = 0;
        while (n != 0) {
            n = n&(n - 1);
            count++;
        }
        return count;
    }

}
